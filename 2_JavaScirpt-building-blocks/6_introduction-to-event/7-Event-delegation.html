<!-- Event delegation
In the last section, we looked at a problem caused by event bubbling and how to fix it. Event bubbling isn't just annoying, though: it can be very useful. In particular, it enables event delegation. In this practice, when we want some code to run when the user interacts with any one of a large number of child elements, we set the event listener on their parent and have events that happen on them bubble up to their parent rather than having to set the event listener on every child individually. -->

<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>event learning section</title>
    <style>
        .tile {
        height: 100px;
        width: 25%;
        float: left;
        }
    </style>
  </head>

  <body>
    <div id="container">
        <p>click everywhere</p>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>
        <div class="tile"></div>

      </div>

    <script>
// Now in JavaScript, we could add a click event handler for every tile. But a much simpler and more efficient option is to set the click event handler on the parent, and rely on event bubbling to ensure that the handler is executed when the user clicks on a tile:
        function random(number) {
            return Math.floor(Math.random() * number);
        }

        function bgChange() {
            const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
            return rndCol;
        }

        const container = document.querySelector("#container");

        // In this example, we're using event.target to get the element that was the target of the event (that is, the innermost element). If we wanted to access the element that handled this event (in this case the container) we could use event.currentTarget.
        container.addEventListener("click", (event) => {
            event.target.style.backgroundColor = bgChange();
        });
    </script>
  </body>
</html>
